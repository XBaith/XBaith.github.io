<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>博客介绍</title>
    <url>/2020/05/08/%E5%8D%9A%E5%AE%A2%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>Hi，大家好，这里是本人的新博客基地，之前的<a href="https://blog.csdn.net/qq_40311709" target="_blank" rel="noopener">博客</a>是在CSDN平台，由于各种原因长时间没有更新，同时想要有更加独立的，更简洁界面的博客，因此将地址转到本站。</p>
<p>今后会追求写出更高质量，更有深度的文章。</p>
]]></content>
  </entry>
  <entry>
    <title>深入理解生产者－消费者队列</title>
    <url>/2020/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%94%9F%E4%BA%A7%E8%80%85%EF%BC%8D%E6%B6%88%E8%B4%B9%E8%80%85%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="生产者-消费者关系"><a href="#生产者-消费者关系" class="headerlink" title="生产者-消费者关系"></a>生产者-消费者关系</h1><p>生产者－消费者关系个人首先在操作系统中接触到，它是信号量（Semaphore，资源使用情况的抽象）机制的一种应用。</p>
<blockquote><p>注意：信号量在 C 语言中是一个结构体型变量，其中 int 型 value 包含表示可用资源数，value = 0：无可用资源，value &lt; 0：有|value|个进程等待此资源。还有 L 为等待此类资源的进程 PCB 表链。<strong>一类资源对应一种信号量。</strong></p>
</blockquote>

<p>生产者－消费者关系中包含一组生产者和一组消费者，两种角色并发地操作一个共享的缓冲池。生产者向缓冲池中放入数据，消费者从缓冲池中取出并消费数据。缓冲池可以缓解生产者和消费者之间的性能差，但不幸的是缓冲池有一定容量，生产者无法向满的缓冲池再放入数据，消费者也无法从空的缓冲池中取出数据。关系如下：</p>
<img src="/2020/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%94%9F%E4%BA%A7%E8%80%85%EF%BC%8D%E6%B6%88%E8%B4%B9%E8%80%85%E9%98%9F%E5%88%97/%E7%94%9F%E4%BA%A7%E8%80%85%EF%BC%8D%E6%B6%88%E8%B4%B9%E8%80%85%E5%85%B3%E7%B3%BB.png" class="" title="[生产者-消费者关系]">

<h1 id="操作系统中用信号量机制解决生产者-消费者问题"><a href="#操作系统中用信号量机制解决生产者-消费者问题" class="headerlink" title="操作系统中用信号量机制解决生产者-消费者问题"></a>操作系统中用信号量机制解决生产者-消费者问题</h1><p>生产者－消费者模式是经典的并发设计模型，操作系统可以对信号量进行 P-V 操作来实现进程间并发，其中 P 操作表示请求系统分配一个单位的资源，V 操作释放一个单位的资源。假设有个信号量 S，由信号量定义可知，P(S) 指请求 S 的一个单位资源，即 S = S - 1；V(S) 释放 S 的一个单位资源，即 S = S + 1。</p>
<p>生产者在向缓存池中放入数据时先检查缓冲池中是否还有容量，对应的先需要执行 P(empty)，即向缓冲池请求一个单位资源，每放入一个数据就有 empty.value -= 1。empty 表示缓冲池空闲的资源，empty 值为 0 就表示缓冲池为空，empty 值一般初始为缓冲池的总容量。放入后需要 V(full) 操作来告诉缓冲池放入了新的数据，其中 full 信号量表示缓冲池中已占有的资源，full 值初始为 0。</p>
<p>消费者消费数据时确保缓冲池容量不能为空。先通过 P(full) 从缓冲池中取出资源，然后通过 V(empty) 操作返回资源。</p>
<img src="/2020/05/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%94%9F%E4%BA%A7%E8%80%85%EF%BC%8D%E6%B6%88%E8%B4%B9%E8%80%85%E9%98%9F%E5%88%97/P-V.png" class="" title="[生产者-消费者问题中的 P-V 操作]">

<h1 id="生产者-消费者队列实践"><a href="#生产者-消费者队列实践" class="headerlink" title="生产者-消费者队列实践"></a>生产者-消费者队列实践</h1><h2 id="用-JDK-中的-BlockingQueue-实现"><a href="#用-JDK-中的-BlockingQueue-实现" class="headerlink" title="用 JDK 中的 BlockingQueue 实现"></a>用 JDK 中的 BlockingQueue 实现</h2><h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>BlockingQueue 可以作为生产者-消费者队列，它是一个接口，值得注意的是当有消息放入队列时。其常见的实现类包括 ArrayBlockingQueue 和 LinkedBlockingQueue，前者用数组实现，后者用链表实现，那么就造成 ArrayBlockingQueue 是有固定容量的，LinkedBlockingQueue 可以是无限容量（不超过物理容量）。</p>
<p>拿 ArrayBlockingQueue 来举例，放入队列有 offer() 和 put() 方法。offer() 方法放入消息时，如果队列没满直接返回 false 否则返回 true。对于 put() 方法，当队列为满时会一直等待，直至队列有空闲位置放入退出。出队就主要是 take() 方法，该方法在队为空时会一直等待新的入队消息。</p>
<pre><code>&#x2F;** Main lock guarding all access *&#x2F;
final ReentrantLock lock;

&#x2F;** Condition for waiting takes *&#x2F;
private final Condition notEmpty;

&#x2F;** Condition for waiting puts *&#x2F;
private final Condition notFull;</code></pre>

<p>从源码中可以看到 BlockingQueue 使用 ReentrantLock 来实现锁操作的，并且配合 Condition 实现类似操作系统中的信号量机制。notEmpty 对应上述的 empty 信号量，notFull 就对应信号量 full。</p>
<pre><code class="java">//入队
public void put(E e) throws InterruptedException {
    checkNotNull(e);
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        while (count == items.length)
            notFull.await();
        enqueue(e);
    } finally {
        lock.unlock();
    }
}
//出队
public E take() throws InterruptedException {
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        while (count == 0)
            notEmpty.await();
        return dequeue();
    } finally {
        lock.unlock();
    }
}</code></pre>
<h3 id="Producer-Consumer-Queue-Demo"><a href="#Producer-Consumer-Queue-Demo" class="headerlink" title="Producer-Consumer Queue Demo"></a>Producer-Consumer Queue Demo</h3><p>在了解了相关概念后就动手实现一个 Demo吧。下例代码用 BlockingQueue 作为生产者-消费者队列，3 个生产者 Producer 和 1 个消费者 Consumer 共享该队列。Producer 向队列添加整数，而 Consumer 消费生产的数据（简单地输出信息），最后利用线程池提交执行。</p>
<pre><code class="java">public class ProducerConsumerQueue {

    /* 生产者 */
    private static class Producer implements Runnable{
        volatile boolean isRunning = true;  //运行状态
        BlockingQueue&lt;Integer&gt; queue; //作为临界区
        static AtomicInteger count = new AtomicInteger();    //数据总数
        final int SLEEP_TIME = 1000; //休眠时间

        Producer(BlockingQueue&lt;Integer&gt; queue) {
            this.queue = queue;
        }

        @Override
        public void run() {
            System.out.println(&quot;Start Producer: &quot; + Thread.currentThread().getId());

            try {
                while (isRunning) {
                    Thread.sleep(SLEEP_TIME);
                    int data = count.incrementAndGet();
                    System.out.println(data + &quot; is produced&quot;);
                    if(!queue.offer(data, 2, TimeUnit.SECONDS)) {
                        System.err.println(&quot;failed to produce &quot; + data);
                    }
                }
            }catch (InterruptedException e){
                e.printStackTrace();
                Thread.currentThread().interrupt();
            }
        }

        public void stopRunning() {
            isRunning = false;
        }
    }

    /* 消费者 */
    private static class Consumer implements Runnable{
        BlockingQueue&lt;Integer&gt; queue;
        final int SLEEP_TIME = 1000;

        Consumer(BlockingQueue&lt;Integer&gt; queue) {
            this.queue = queue;
        }

        @Override
        public void run() {
            System.out.println(&quot;Start Consumer: &quot; + Thread.currentThread().getId());

            try{
                while(true) {
                    int data = queue.take();   //消费数据
                    System.out.println(data + &quot; is consumed&quot;);
                    Thread.sleep(SLEEP_TIME);
                }
            }catch (InterruptedException e) {
                e.printStackTrace();
                Thread.currentThread().interrupt();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        ArrayBlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;&gt;(10);
        Producer producerA = new Producer(queue);
        Producer producerB = new Producer(queue);
        Producer producerC = new Producer(queue);
        Consumer consumerA = new Consumer(queue);

        ExecutorService service = Executors.newCachedThreadPool();
        service.submit(producerA);
        service.submit(producerB);
        service.submit(producerC);
        service.submit(consumerA);

        Thread.sleep(10 * 1000);
        producerA.stopRunning();
        producerB.stopRunning();
        producerC.stopRunning();
        System.out.println(&quot;stop producing...&quot;);

        service.shutdown();
    }
}</code></pre>
<h2 id="Disruptor-实现高性能生产者-消费者队列"><a href="#Disruptor-实现高性能生产者-消费者队列" class="headerlink" title="Disruptor 实现高性能生产者-消费者队列"></a>Disruptor 实现高性能生产者-消费者队列</h2><p>Disruptor 是英国外汇交易公司 LMAX 开发的一个高性能队列，研发的初衷是解决内存队列的延迟问题（在性能测试中发现竟然与 I/O 操作处于同样的数量级）。基于 Disruptor 开发的系统单线程能支撑每秒 600 万订单，2010 年在 QCon 演讲后，获得了业界关注。</p>
<p>目前，包括 Apache Storm、Camel、Log4j 2 在内的很多知名项目都应用了 Disruptor 以获取高性能。</p>
<blockquote><p>注意：这里所说的队列是系统内部的内存队列，而不是Kafka这样的分布式队列。</p>
<p>推荐阅读：<a href="https://tech.meituan.com/2016/11/18/disruptor.html" target="_blank" rel="noopener">美团技术团队实践</a></p>
</blockquote>

<h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><pre><code class="java">public class DisruptorPCQueue {

    /* 消息 */
    private static class Data {
        private int value;

        public int getValue() {
            return value;
        }

        public void setValue(int value) {
            this.value = value;
        }
    }

    private static class Producer {
        private final RingBuffer&lt;Data&gt; ringBuffer;   //环形缓冲区

        private Producer(RingBuffer&lt;Data&gt; ringBuffer) {
            this.ringBuffer = ringBuffer;
        }

        public void pushData(ByteBuffer byteBuffer) {
            long sequence = ringBuffer.next();
            Data data = ringBuffer.get(sequence);
            data.setValue(byteBuffer.getInt(0)); //填充数据
            ringBuffer.publish(sequence);
        }
    }

    private static class Consumer implements WorkHandler&lt;Data&gt; {

        @Override
        public void onEvent(Data data) throws Exception {
            System.out.println(&quot;Consumer &quot; + Thread.currentThread().getId()
                    + &quot; process data: [&quot; + data.getValue() + &quot;]&quot;);
        }
    }

    private static class DataFactory implements EventFactory&lt;Data&gt; {
        @Override
        public Data newInstance() {
            return new Data();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Disruptor&lt;Data&gt; disruptor = new Disruptor&lt;&gt;(new DataFactory(),
                1024,
                Executors.defaultThreadFactory());
        disruptor.handleEventsWithWorkerPool(new Consumer(),
                new Consumer(), new Consumer());
        disruptor.start();

        RingBuffer&lt;Data&gt; ringBuffer = disruptor.getRingBuffer();
        Producer producer = new Producer(ringBuffer);
        ByteBuffer byteBuffer = ByteBuffer.allocate(8);
        for(int n = 0;; n++) {
            System.out.println(&quot;add data &quot; + n);
            byteBuffer.putInt(0, n);
            producer.pushData(byteBuffer);
            Thread.sleep(100);
        }
    }
}</code></pre>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java并发</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
</search>
